# ES6 Modular

> ECMA 参考了众多社区模块化标准，在2015年，伴随 ES6 发布了 官方的模块化标准

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * ES6 模块化 具有以下特点
 * 
 * 
 */

1) 使用 '依赖预声明' 的方式导入模块

    - 依赖延迟声明: 当条件满足或需要执行时，才加载模块文件
    
      ( 优点: 某些时候可以提高效率; 缺点: 无法在入口文件执行初确定模块依赖关系( 相对比较模糊 ); )
    
    - 依赖预声明: 
    
      ( 优点: 可以在入口文件执行初确认模块依赖关系; 缺点: 某些时候执行效率较低; )

2) 灵活的多种导入和导出方式

3) 规范的路径表示法: 所有路径必须以 './ or ../' 开头( 无前缀表示倒入 node_modules 中的库 )


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### Link Modular Files

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 引入模块入口文件                 // type="module" 浏览器必须以该方式引入 ES6模块
 *                               // 向后兼容，此时浏览器会认为引入的为模块
 * 
 * 
 * @modularPath: 必须以 './ or ../' 开头( 无前缀表示倒入 node_modules 中的库 )
 */

<script src="modularPath: string" type="module">


//-------------------------------------------------------------------------------------------------------------------//



                        + ---------- ES6 Modular ------------------- +
                        |                                            |
                        |                                            |
                        |          + ---------------- +              |
                        |          |                  |              |
                        |          |                  |              |
                                   |                  |       + ----------- +
             + - functio-sort      |                  |       |             |
             |                     |                  |       |             |
             |          |          |                  |       |             |
    default  |          |          |  Hide internal   |       |   default   |
             |                     |                  |       |             |
    export   + - obj-helper        |  implementation  |       |   export    |
             |                     |                  |       |             |
    import   |          |          |                  |       |   import    |
             |          |          |                  |       |             |
             |                     |                  |       |             |
             + - string-name       |                  |       |             |
                                   |                  |       + ----------- +
                        |          |                  |              |
                        |          + ---------------- +              |
                        |                                            |
                        |                                            |
                        + ------------------------------------------ +



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

## Export and Import

#### Basic Export

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * Basic single Export
 * 
 * 
 * @state-express: 声明的表达式
 */

export state-express;


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


export let test = 996;                      // 必须声明的表达式

export function test() {};                  // 必须命名函数


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


let test = 996;

export test;                                // 无法导出变量名

export function() {};                       // 无法导出匿名函数

export 996;                                 // 无法导出未命名的值


//-------------------------------------------------------------------------------------------------------------------//


/**
 * Basic Multiple Export
 * 
 * 
 * @{}: 一次性导出单个或多个属性或这值( 约束导出的属性或变量名称的语法, 并非导出对象 )
 */

export { propName, methodName };


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


const name = 'alpha',
    age = 18,
    gender = 'male,
    saHi = function() {};


export {

    name, age, gender, sayHi
};


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### Basic Import

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * Basic Import
 * 
 * 
 * @exportList: 导出的变量或方法名称
 * 
 * @exportPath: 导出文件相对于入口文件的路径，必须以  './ or ../' 开头
 */

// 内部实现: 预编译时，会把 import 语句提升到当前 js 文件的最顶部( 依赖预加载 )


import { exportListItemItem } form "exportPath";


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


1) import 时，可以通过关键字 as 对导入属性或方法重新命名

2) import 时，无法对导入的属性或方法重新赋值，导入时默认所有变量和方法都为 常量

3) 可以使用 * 导入所有基本属性和方法( 一次性导出时，必须使用 as 重命名导出对象 )


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * 仅运行模块，不使用该模块内部的任何导出
 * 
 * 
 */

export "exportPath";


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### Default Export

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * Default Export
 * 
 * 
 * 每个模块，除了允许有多个基本导出以外，还允许有一个默认导出
 * 
 * 默认导出类似于 CommonJS 中的 module.exports               // 由于只有一个，因此无需具名
 */

* 每个模块有且仅有一个  '默认导出'，因此每个模块不允许有多个默认导出的语句

export default exportDataName

export { exportDataName as default }


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### Default Import

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * Default Import
 * 
 * 
 * 由于默认导入时变量名是自定义的，因此无别名一说
 */


import exportDataName form "exportPath";


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * 同时导入某个模块的默认导出和基本导出
 * 
 * 
 */

import exportDataName, { exportListItem } from "exportPath";


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

## keyword

#### as of keyword

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * as
 * 
 * 无论导出还是导入，都可以重定义导出或导入的命名
 */


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### * of keyword

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * * 
 * 
 * 使用 * ，会将所有基本导出和默认导出聚合到一个对象中，默认导出会作为属性 default 存在
 */

import * as result form "demo.js";

result.default;                 // 默认导出的数据


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

## Precautions

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 尽量导出不可变的值
 * 
 * 
 * export const prop/function(){}                       // 尽量使用 const 避免导出的变量或方法后期可能被修改
 */

当导出一个内容时，尽量保证该内容是不可变的( 大部分情况下都是如此 )

因为，虽然导入后，无法更改导入内容，但是在导入的模块内部却有可能发生更改，这将导致一些无法预料的事情发生


//-------------------------------------------------------------------------------------------------------------------//



/**
 * 使用无绑定的导入，用于执行一些初始化代码
 * 
 * 
 * 若只想执行模块中的一些代码，并不需要导入它的任何内容，则可以使用无绑定的导入
 */

import "./demo.js";                                     // 此模块中的代码仅运行加载一次，并无导入任何内容


//-------------------------------------------------------------------------------------------------------------------//


/**
 * 将多个模块中的部分功能的返回封装为一个返回结果
 * 
 * 
 * 有时候，需要用一个模块封装多个模块，然后有选择的将多个模块的内容分别导出，则可使用下面的语法
 */

export { exportListItem } from "exportPath";             // 允许直接设置导出为 别的模块的内容


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```