# Performance optimization

## Problem

#### 性能优化

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 性能优化
 * 
 * 
 * 构建性能 + 传输性能 + 运行性能 
 */


//-------------------------------------------------------------------------------------------------------------------//


/**
 * 构建性能
 * 
 * 
 */

描述: 指开发阶段的构建性能

目标: 降低从打包开始，到代码效果呈现所经过的时间

影响: 构建性能会影响开发效率，构建性能越高，开发过程中时间浪费的越少


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * 传输性能
 * 
 * 
 */

描述: 指打包后的 JS代码，用户请求后 由服务器传输到浏览器经过的时间

优化思路: 

1) 总传输量:

   所需传输的 JS文件 内容加起来称为 总传输量，重复代码越少，总传输越少

2) 文件数量:

   当访问页面时，需要传输的 JS 文件数量越多，http 请求即越多，相应速度越慢

3) 浏览器缓存

   JS 文件会被 浏览器缓存，被缓存的文件不会再进行传输


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * 运行性能
 * 
 * 
 */

描述: 指 JS代码 在浏览器端的运行速度，取决于 开发者如何书写 高性能代码


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

## Resolve

#### 减少模块解析

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



chunk {         // 用于记录模块转换后的代码
    
    'moduleId': 'tranformedCode'
    './scr/index.js': 'xxxxxxx',
    ...
}
                    /\
                   /||\
                    ||
                  检查记录
       
入口 ----> 入口模块文件 -------> 已记录则结束 ---> 读取文件内容 --> AST( 抽象语法树 ) ---> 将依赖关系保存 ------------>>
                              未记录则继续                        语法分析        ( 保存至 dependencies 文件中 )        
                                                               树形结构遍历      ( 获取 require(); 中 )
                                                               获取所有依赖      ( 所对应的完整路径作为 moduleId )


>> 替换依赖函数 ----------------------------------------> 保存转换后的模块代码 ----------------------------> 入口
require('a'); =>  __webpack_require('./src/a.js');
                                                                          根据 dependencies 中的依赖关系
                                                                              递归加载所有依赖模块


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


    -------> 当前模块是否满足某个规则 -------> 读取规则中对应的 loaders
                    |                                |
                    | no ( empty-arr )               |
                    |                               \|/
                    |
                    + -------------------------> loaders arr
                                                     |
                                                     |
                                                    \|/
    
    + --------------------------------------------------------------- +        
    |                                                                 |     \
    |                code          code          code          code   | ---- \
    |   <-- loader1 <---- loader2 <---- loader3 <---- loader4 <----   | ---- /      source code
    |                                                                 |     /
    + --------------------------------------------------------------- +      


//-------------------------------------------------------------------------------------------------------------------//


/**
 * 模块解析
 * 
 * 
 * 包含: 抽象语法树分析，依赖分析，模块语法替换
 */


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * 若不做模块分析
 * 
 * 
 * 则该模块经过 loaders 处理后，直接输出最终代码( 没有 抽象语法树分析，依赖分析，模块语法替换 )
 */


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * 哪些模块不需要解析
 * 
 * 
 * 该模块无其他依赖( 通常为已打包好的第三方模块 )
 */


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * 根据正则匹配，设置模块不解析
 * 
 * 
 * 设置后无法该模块无法 抽象语法树分析，依赖分析，模块语法替换
 */

module.exports = {

    module: {
    
        noParse: /jquery/
    }
};


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### 优化 loader 性能

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 限制 loader 应用 范围
 * 
 * 
 * 对于某些库，避免使用已打包好的 loader
 */

// eg: babel-loader 可以转换 ES6 或更高版本的语法
//     但有部分库本身就是用低版本的语法书写的，不需要转换
//     使用 babel-loader 反而会浪费构建时间
//
//     lodash 是在 ES5 之前出现的库( 使用 ES3 语法 )


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


module.rule.exclude || module.rule.include

module.exports = {

    module: {
    
        rules: {
        
            {
                test: /\.js$/,
                exclude: "loadash",
                use: "babel-loader"
            }
        }
    }
};


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


{
    test: /\.js$/,
    exclude: /lodash/,
    use: ["babel-loader"]
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 缓存 loader 的结果                // cache-loader
 * 
 * 
 * 基于: 若某个文件内容不变，结果相同的 loader 解析后，解析结果仍不改变
 * 
 * 则: 可以将 loader 的解析结果保存下来，便于后续解析直接使用
 */

npm install --save-dev cache-loader


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


module.exports = {
    module: {
        rules: [
            {
                test: /\.css$/,
                use: ["cache-loader?cacheDirectory=\./cache", "style-loader", "css-loader?modules"]
            },
            {
                test: /.less$/,
                use: ["cache-loader?cacheDirectory=\./cache", "style-loader", "css-loader?modules", "less-loader"]
            },
            {
                test: /\.(jpe?g)|(png)|(gif)$/,
                use: ["cache-loader?cacheDirectory=\./cache", "file-loader"],
            },
            {
                test: /\.js$/,
                use: ["cache-loader?cacheDirectory=\./cache", "babel-loader"]
            }
        ]
    },
};


//-------------------------------------------------------------------------------------------------------------------//


/**
 * loader.pitch
 * 
 * 
 * cache-loader 运行原理
 */
 
 
    {
        test: /demo/,
        use: ["loader-1", "loader-2", "loader-3"]
    }


    根据路径判断是否有缓存，若当前 loader 有缓存，则直接返回该 loader 缓存的源代码

            path              path              path
    start --------> loader1 --------> loader2 --------> loader3 ----------------> +
                    .pitch            .pitch            .pitch                    |
                       |                 |                 |                      |   
                       |                 |                 |                + ---------- +    
                       |                 |                 |                |            |
                       |                 |                 |                |   source   |
     + <-------------- + <-------------- + <-------------- +                |            |
     |                                                                      + ---------- +              
     |                                                                            |      
     |                                                                            |      
    end   <-------- loader1 <-------- loader2 <-------- loader3 <---------------- +
           source            source            source


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 为 loader 运行开启多线程             // thread-loader
 * 
 * 
 * thread-loader 会开启一个线程池( 默认线程数量根电脑配置有关 )
 * 
 * webpack 会把 添加在 "thread-loader" 后的 loader 放入线程池中运行，以提高效率
 * 
 * 但后续添加的 loader 无法:
 * 
 *      1) 无法使用 webpack api 生成文件
 * 
 *      1) 无法使用自定义的 plugin api
 * 
 *      1) 无法访问 webpack options
 */

// 开启和管理线程需要消耗时间，在小型项目中使用 "thread-loader" 反而会增加构建时间


npm install --save-dev thread-loader


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


module.exports = {
    module: {
        rules: [
            {
                test: /\.css$/,
                use: ["thread", "style-loader", "css-loader?modules"]
            },
            {
                test: /.less$/,
                use: ["thread", "style-loader", "css-loader?modules", "less-loader"]
            },
            {
                test: /\.(jpe?g)|(png)|(gif)$/,
                use: ["thread", "file-loader"],
            },
            {
                test: /\.js$/,
                use: ["thread", "babel-loader"]
            }
        ]
    },
};


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### 热替换( HMR )

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * Hot Module Replacement
 * 
 * 
 * 热替换并不能降低构建时间( 可能还会稍微增加 )，但可以降低代码改动后到效果呈现之间的时间
 */


    // webpack-dev-server 普通运行流程: 重新请求所有资源

    Modify-Code ------> Restart-Webpack -----> Browser-Re-Request -----> Browser-Render
        |                                        all-source                     |
        |                                        page-refresh                   |
        |                                                                       |
        |                                                                       |
        |                                                                       |
        + --------------------------- Monitor --------------------------------- +



    // webpack-dev-server 热替换运行流程: 重新仅请求改动的资源

    Modify-Code ------> Restart-Webpack -----> Browser-Re-Request -----> Browser-Render
        |                                        changed-source                 |
        |                                                                       |
        |                                                                       |
        |                                                                       |
        + --------------------------- Monitor --------------------------------- +


//-------------------------------------------------------------------------------------------------------------------//


/**
 * 开启 热更新
 * 
 * 
 * 
 */


module.exports = {

    devServer: {
    
        hot: true
    },
    
    plugins: [
    
        new webpack.HotModuleReplacementPlugin()            // 目前版本已默认载入，仅开启 devServer 设置即可
    ]
};


// 在入口文件( index.js )中加入以下代码

if (module.hot) {               // 判断是否开启热更新

    module.hot.accept();        // 开启热更新
}


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


if (module.hot) {

    module.hot.accept();
}


module <= function( moduule, exports, __webpack_require__ ) {}

hot    <= 在 webpack.config.js 中设置 devServer.hot = true; 会将此属性作为参数传入

默认情况下，webpack-dev-server 无论是否开启热更新，当重新打包后，都会调用 location.reload( 刷新页面 )


但 运行了 module.hot.accept(), 将改变

module.hot.accept(); 作用是让 webpack-dev-server 通过 socket 管道，把服务器更新的内容发送到浏览器

然后，将结果交给插件 HotModuleReplacementPlugin();

插件 HotModuleReplacementPlugin(); 会重新生成并覆盖原始代码，然后将代码重新执行


//-------------------------------------------------------------------------------------------------------------------//


/**
 * css 热更新
 * 
 * 
 * css 热更新，需要使用 style-loader
 */


因 热替换发生时，HotModuleReplacementPlugin(); 只会简单的重新运行模块代码

因此 style-loader 的代码一运行，就会重新设置 style 元素中的样式

而 mini-css-extract-plugin，由于它生成文件是在 构建期间，则运行期间无法改动文件，则该插件在热更新中无效



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### 分包

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 什么是分包
 * 
 * 
 */

讲一个整体的代码，拆分到不同的打包文件中


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * 为什么要分包
 * 
 * 
 */

减少公共代码，降低总体积( 部分大型大地方库: juery ... )

充分利用浏览器缓存( 加载第三方库后，因文件不会更改，则无需重新加载，再次请求则可以直接调用缓存 )


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * 何时分包
 * 
 * 
 */

多个 chunk 引入了公共模块

公共模块体积较大 或 减少变动


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * 如何分包
 * 
 * 
 */

手动分包

自动分包


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 手动分包
 * 
 * 
 */


// 手动打包 - 过程

1) 开启 output.libray 暴露公共模块

2) 利用 webpack.DllPlugin(); 创建资源清单

3) 利用 webpack.DllReferencePlugin(); 使用资源清单


// 手动打包 - 注意事项

1) '资源清单' 不参与运行，可以不放到 打包目录中

2) 需要手动引入 公共 JS 打包文件，以及避免被删除( cleanPlugin 在打包时会清空目录 )

3) 不要对小型公共 JS 库 使用


// 手动打包 - 优点

1) 极大的提升自身模块的打包速度

2) 极大的缩小了自身文件体积

3) 有利于浏览器缓存第三方库的公共代码


// 手动打包 - 缺点

1) 使用较繁琐

2) 若第三方库中包含重复代码，则效果不太理想


//-------------------------------------------------------------------------------------------------------------------//


step - 1: 单独打包公共模块

          公共模块会被打包称为动态链接库( dll Dynamic Lik Library )，并生成资源清单


                + --------- +
                |           |
                |           | ====> dll/jquery.js
                |           |       暴露变量
    jquery ---> +  jq.pkg   |
                |           |
                |           | ====> dll/lodash.js
                |           |       暴露变量
                |           |
    lodash ---> +  ld.pkg   |
                |           | ====> manifest.json                                   // 生成资源清单
                |           |       ./node_modules/jquery:jquery, dll/jquery.js
                |           |       ./node_modules/lodash:lodash, dll/lodash.js
                |           |       ...
                + --------- +


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


为公共模块创建单独的配置文件

touch webpack.dll.config.js         // dll: dynamic link library( 动态链接库 )

echo 'const webpack = require("webpack"),
    path = require("path");

module.exports = {
    mode: "production",
    entry: {
        jquery: ["jquery"],
        lodash: ["lodash"]
    },
    output: {

        filename: "dll/[name].js",
        library: "[name]",                  // 每个 bundle 暴露的全局变量名
        libraryTarget: "var"                // 全局暴露变量的方式，默认: var
    },
    plugins: [
        new CleanWebpackPlugin({
        
            // 因 clean-plugin 打包时会清空 dist/ 目录，需设置匹配规则
            // 
            // *:  匹配任意字符，不包括 /
            // ?:  匹配任意单个字符，不包括 /
            // **: 匹配任意数量的字符，包括 /
            // {}: 匹配表达式
            // !:  不匹配指定字符
            
            cleanOnceBeforeBuildPatterns: ["**/*", "!dll", "!dist/"]
        }),
        new webpack.DllPlugin({

            path: path.resolve(__dirname, "dll", "[name].manifest.json"),           // 生成资源清单
            name: "[name]"                                                          // 源清单中暴露的全局变量名规则
        })
    ]
};' > webpack.dll.config.js


// 手动打包公共模块

"dll": "webpack --config webpack.dll.config.js"         // npm run dll



//-------------------------------------------------------------------------------------------------------------------//


step - 2: 根据入口模块正常打包

          打包时，若发现模块中使用了 '资源清单' 中描述的模块，则不会生成以下代码


    import $ from "jquery";
    import _ from "lodash";
    
    _.isArray($(".red"));



// 模拟内部原理

(function(modules){

    // ...
    
}({

    // index.js 打包结果并无变化
    
    "./src/index.js": function(module, exports, __webpacl_require__) {
    
        var $ = __webpack_require__("./node_modules/jquery/index.js"),
            _ = __webpack_require__("./node_modules/lodash/index.js");
            
        _.isArray($(".red"));
    },
    
    // 因 资源清单中 存在，则 jquery 的源码包 不会打包在这里
    
    "./node_modules/jquery/index.js": function(module, exports, __webpacl_require__) {
    
        module.exports = jquery;
    },
    
    
    // 因 资源清单中 存在，则 lodash 的源码包 不会打包在这里
    
    "./node_modules/lodash/index.js": function(module, exports, __webpacl_require__) {
    
        module.exports = lodash;
    }
}));


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 自动分包                 // 重点: 分包策略
 * 
 * 
 * 自动分包从更宏观的角度控制分包，一般不针对某个具体的包进行控制
 * 
 * 分包策略: webpack 会根据 分包策略 自动进行分包
 */

// webpack 内部使用 SplitChunksPlugin 进行分包
// 
// 之前的 CommonsChunkPlugin 也可以实现分包( 由于该库某部分不完善 )，至 webpack4 后，已被 SplitChunksPlugin 取代


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 自动分包思路


1) 检查每个 chunk 编译的结果

2) 根据分包策略，匹配到满足策略的模块 

3) 根据分包策略，生成新的 chunk 打包这些模块( 分包体积无变化，抽离公共代码 )

4) 将打包出去的代码从原始包中移除，并修改原始包代码


// 自动分包代码逻辑变动

1) 分包的代码中加入了一个 全局变量( 数组 )，其中包含公共模块的代码




//-------------------------------------------------------------------------------------------------------------------//


                + ---------- webpack ---------- +
                |                               |
                |   + ------------ +            |
                |   |              |            |       
    chunk1 ---> +   |              |  chunk1    | ====> bundle1.js
    commonCode  |   |              |            |
                |   | distribution |  chunk2    | ====> bundle2.js
                |   | strategy     |            |       
                |   |              |  chunk3    | ====> bundle_common.js
    chunk2 ---> +   |              |            |
    commonCode  |   |              |            |
                |   + ------------ +            |       
                |                               |       
                + ----------------------------- +


1) 分包策略: 重要，并且决定了如何分包

2) 分包时，开启了一个 新的chunk，对分离的模块进行打包

3) 打包结果中，公共的部分被提取出来形成了一个单独的文件，该文件属于 新chunk 的产物


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * 分包策略             // 基于全局
 * 
 * 
 */


module.exports = {

    optimization: {
        splitChunks: {
        
            /**
             * chunks.value
             * 
             * 
             * all:         // 对 '所有chunk' 都应用 分包策略
             * 
             * async:       // 仅对 '异步chunk' 引用 分包策略额                // default
             * 
             * initial:     // 仅针对普通 chunk 应用分包策略
             */
            
            chunks: "all",  // 通常配置为 all
            
            
            /**
             * maxSize      // 该配置可以控制包的最大字节数                   // 意义不大                  
             * 
             * 
             * 若某个包( 包括分出来的包 )超过了该值，则 webpack 会尽可能的将其分离成多个包( 再次分为多个包，并不会改变总大小 )
             * 由于分包的基础单位是模块，若某个完整的模块超过了该值，则仍无法分离为多个包
             * 
             * 分包的目的: 提取大量公共代码，减少总体积和充分利用浏览器缓存
             * 
             * 若分为多个包，则需要浏览器多线程加载( 若浏览器不支持多线程加载，则还需要多增一次 http 请求 )
             */
            
            maxSize: 6*1024,
            
            
            /**
             * 其他配置
             * 
             * 
             * 一般不做更改
             */
            
            automaticNameDelimiter: ".",       // 用于设置新建 chunk 名称的分隔符( 默认值: ~ )
            
            minChunks: 1,           // 用于提取公共模块，当 公共代码 被多少模块引用时，才被提取为公共模块分包( 默认值: 1 )
            
            minSize: 300000         // 用于提取公共模块，当 公共代码 达到多少字节时，才被提取为公共模块分包( 默认值: 300000 )
        }
    },
};


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * 缓存组              // 默认情况下，webpack 提供两个缓存组
 * 
 * 
 * 实际上 分包策略 基于 缓存组( 默认有两个缓存组 vendors & default )
 * 
 * 每个缓存组 提供一套独有的策略，webpack 按照 缓存组 的优先级处理相应缓存组，被缓存组处理过的分包不需要再次分包
 */


module.exports = {

    optimization: {
        splitChunks: {
        
            chunks: "all",                              // 用于设置所有 chunk 都使用 分包策略
            
            cacheGroups: {

                // 属性名为缓存组名称，影响分包的 chunk 名
                // 属性值巍峨缓存组配置，缓存组集成所有的全局配置，也有自己特殊的配置

                vendors: {
                    test: /[\\/]node_modules[\\/]/,     // 当匹配到相应模块时，将这些模块进行单独打包
                    priority: -10                       // 缓存组优先级，优先级越高，该策略越优先处理，默认为 0
                },
                default: {
                    minChunks: 2,                       // 覆盖全局配置，将最小 chunk 引用数改为 2
                    priority: -20,                      // 缓存组优先级
                    reuseExistingChunk: true            // 重用已被分离出去的 chunk
                }
            }
        }
    }
};


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 配合多页应用               // 因模块化抽出公共代码，需要手动配置引用相应的模块，可用测试阶段的 html-webpack-plugin@next
 * 
 * 
 * 虽然目前单页面应用是主流，但有可能还是会遇到多页应用
 */


npm i -D html-webpack-plugin@next           // 下一个版本中支持了自动为 html 配置所需模块的引用


new HtmlWebpackPlugin({

    template: "./public/index.html",
    chunks: ["main"]                        // 设置入口模块名称( 用于自动分析所需引入依赖文件 )
                                            // entry.mian = "./src/index.js"
})


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


new HtmlWebpackPlugin({

    template: "./public/index.html",
    chunks: ["index~other", "vendors~index~other", "index"]         // 需要手动配置 chunk
})


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

## 单模块体积优化

#### 代码压缩

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 为什么要进行代码压缩
 * 
 * 
 */

减少代码体积，破快代码的可读性，融合代码提升代码破解成本


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * 什么时候需要进行代码压缩
 * 
 * 
 */

生产环境


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * 使用什么压缩工具
 * 
 * 
 * UglifyJs & Terser
 */


UglifyJs:           // 不支持 ES6 语法，已存在多年的传统压缩工具

曾经前端应用的必备工具，目前已被 Terser 代替


Terser:             // 支持 ES6 语法，新起压缩工具

支持 ES6 语法，webpack 的安装内置 Terser，当启用 '生产环境' 后，即可用其进行压缩


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * Terser options
 * 
 * 
 * 
 */


{
    toplevel: true,         // 
    
    pure_funcs: [],         // 
    
    compress: {},           // 
    
    mangle: {},             // 
    
    ouput: {},              // 
    
    parse: {},              // 
    
    rename: {},             // 
}


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * side effectt         // 副作用代码
 * 
 * pure function        // 纯函数
 * 
 * 
 * 函数运行过程中，对外部环境造成了影响
 */

async function          // 异步代码

local storage           // 浏览器本地存储

change code of outer    // 修改外部环境代码


//-------------------------------------------------------------------------------------------------------------------//


/**
 * webpack + terser
 * 
 * 
 * webpack 自动集成了 Terser
 */

npm i --save-dev terser-webpack-plugin

npm i --save-dev optimize-css-assets-webpack-plugin


const TerserPlugin = require(""),
    OptimizeCSSAssetsPlugin = require("");

modult.exports = {

    optimizattion: {
    
        minimize: true,             // 是否开启压缩，默认生产环境自动开启

        minimizer: [                // 设置压缩时，匹配的插件集合数组

            new TerserPlugin(),                         // 针对 js 压缩( 默认已有 )
            new OptimizeeCSSAssetsPlugin(),             // 针对 css 压缩
        ]
    }
};


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### tree shaking

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * tree shaking                 // webpack2 开始就已支持并默认开启 tree shaking
 * 
 * 
 * 用于移除模块中不会被用到的导出代码
 */


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


export function add(a, b) {                 // myMath module

    console.log("add");
    
    return a + b;
}

export function sub(a, b) {                 // myMath module

    console.log("sub");
    
    return a - b;
}


import {add} from "./myMath";               // index module: 仅调用了 add();

console.log(add(1, 2));


//-------------------------------------------------------------------------------------------------------------------//


/**
 * 原理
 * 
 * 
 * webpack 会保证代码正常运行的前提下，使用 tree shaking        // 不会优化未知的有风险项
 */

webpack 会从 入口模块 寻找依赖关系
        
    // 为何依据 ES6 语法，而不是 commonJS: 因 ES6 语法中模块的导入和导出可控性更高，利于稳定分析依赖关系
    // 
    // 1. ES6 导入导出语句置于模块顶层
    // 2. import 的模块名只能是字符串常量
    // 3. import 绑定的变量不可变

    依据 ES6 语法的导出和导入语句判断，该模块的部分功能依赖了哪个模块


在个人编写代码时: 有利于 webpack 分析模块之间的功能依赖关系，并为 "无副作用代码" 注释 "dead code"，然后交由压缩工具

    1. 使用 export xxx 导出，而不是 export default {xxx} 导出
    
    2. 使用 import {xxx} from "xxx" 或 import * as xxx from "xxx" 导入，而不是 import xxx from "xxx" 导入


压缩工具会 将注释有 "dead code" "无副作用代码" 移除


//-------------------------------------------------------------------------------------------------------------------//


/**
 * 部分第三方库使用 commonjs 方式导出，或该库没有提供普通的 ES6 方式导出
 * 
 * 
 * 对于这些库，tree shaking 无法发挥作用
 * 
 * 需要寻找该库的 es6 版本               // 大多数流行的第三方库都发布了 es6 版本
 */


lodash                  // es5 commonjs

lodash-es               // es6 


//-------------------------------------------------------------------------------------------------------------------//


/**
 * 作用域分析            // 使用有风险
 * 
 * 
 * 利用 webpack-deep-scope-plugin 解决作用域分析
 */

tree shaking 本身并没有完善的作用域分析，可能导致在一些额 "dead code" 函数中的依赖仍然会被视为依赖


//-------------------------------------------------------------------------------------------------------------------//


/**
 * 副作用问题                // 通常不处理，第三方库大多数在自己的 package.json 中已配置
 * 
 * 
 * webpack 会首先保证 代码正常运行，再使用 "tree shaking" 优化代码
 * 
 * 当 webpack 无法确定某个模块是否有副作用时，通常都会作为有副作用处理( 保留有副作用的代码 )
 */


// 可以在 page.json 中添加  "sideEffects": "false"

{
    "sideEffects": "false"                  // 所有模块都为有副作用模块
}

{
    "sideEffects": [                        // 指定某个模块或匹配符合规则的模块为有副作用模块
    
        "!src/common.js"
    ]
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### css tree shaking

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * css tree shaking                 // 因 css 和 es6 毫无关系，则需要依靠其他创建分析
 * 
 * 
 */

mini-css-extract-plugin             // 提取 css 到单独的文件

purgecss-webpack-plugin             // 删除 未使用的 css 样式代码

glob-all                            // 根据字符 匹配文件或目录 ( **, *, ! ... )


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### 懒加载

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


import {chunk} from "lodash-es";

const btn = document.querySelector("button");

btn.onclick = function () {

    const result = chunk([3, 4, 5, 6, 7, 8], 2);

    console.log(result);
};


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


const btn = document.querySelector("button");
btn.onclick = async function () {

    /**
     * 远程加载     // 此时无法 tree shaking，因为异步加载属于副作用代码，webpack 无法判断是否依赖
     *
     *
     * import 是 ES6的草案
     * 浏览器会使用 JSOP的方式远程读取一个 JS 模块
     * import() 会返回一个 promise
     *
     *
     * 原理: 将所加载的数据放入 webpackJsonp:[]; 再调用
     */

    const {chunk} = await import(/*webpackChunkName: lodash*/"lodash-es");

    const result = chunk([1, 2, 3, 4, 5, 6], 2);

    console.log(result);
};


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// index.js

const btn = document.querySelector("button");
btn.onclick = async function () {

    /**
     * 将所需的 chunk 资源转换为 '静态资源'
     *
     *
     * 由另一个模块导入，将动态资源转换为静态资源，以便于 tree shaking 分析依赖，从而优化代码
     */

    const {chunk} = await import(/*webpackChunkName:"lodash"*/"./assets/js/util.js");

    const result = chunk([1, 2, 3, 4, 5, 6], 2);

    console.log(result);
};


// util.js

export {chunk} from "lodash-es";


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### ESLint

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * ESLint               // 协同开发时，协助统一书写代码规范的辅助插件
 * 
 * 
 * 针对 JS 代码风格的检查工具
 * 
 * 当不满足其要求的风格时，会给予警告
 */

官网: https://eslint.org/

民间中文: https://eslint.bootcss.com/


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


npm i [-g] -D eslint

npx eslint --init


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// step - 1

webstrom 中内置 eslint


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// step - 2

eslint 依赖 .eslintrc( 配置文件，文件类型可选 )，若无该文件则无法匹配语法规则


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// step - 3

npm i [-g] -D eslint            // 安装 eslint

npx eslint --init               // 初始化 eslint


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// step - 4

.eslintrc.json                  // eslint 配置文件( 无该文件则无法匹配语法规则 )
                                // eslint 会识别 .eslintrc.* 文件，也能够识别 package.json 中的 eslintConfig

.eslintignore                   // 运行 eslint 时，需要忽略的文件匹配规则 


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


{
    "配置代码的运行环境":"//",
    "env": {

        "代码是否在浏览器环境中运行": "//",
        "browser": true,

        "是否支持ES6全局API":"//",
        "es2020": true
    },

    "设置该语法规范继承自":"//",
    "extends": [
        "airbnb-base"
    ],

    "配置 elint 对哪些语法支持":"//",
    "parserOptions": {

        "设置支持的 ES 语法版本":"//",
        "ecmaVersion": 11,

        "设置源码模块化标准 script 传统脚本 module 模块化脚本":"//",
        "sourceType": "module"
    },

    "设置 eslint 语法解析器":"//",
    "parser": "Espree",

    "配置额外的全局变量":"//",
    "globals": {

        "var1": "readonly",
        "var2": "writable"
    },

    "语法规则集":"//",
    "rules": {

        "关闭 该规则检查":"//",
        "off": "0",

        "警告 并不会导致程序推出":"//",
        "warn": "1",

        "错误 当触发时 程序会推出":"//",
        "error": "2",

        "": ""
    }
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### bundle analyzer

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * bundle analyzer
 * 
 * 
 * 可视化模块分析辅助插件
 */


npm i -D webpack-bundle-analyzer


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


WebpackBundleAnalyzer = require("webpack-bundle-analyzer").BundleAnalyzerPlugin;


new WebpackBundleAnalyzer({

    analyzerMode: "server"                  // 展示分析结果的模式: disable，server( default )，static
})


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### gzip

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * gzip
 * 
 * 
 * 一种压缩文件的算法
 */

优点: 传输效率可能得到大幅提升

缺点: 服务器的压缩需要时间，客户端的解压需要时间


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// B/S 结构中的压缩传输模拟

当浏览器得知服务器支持某种压缩格式，则传递相应格式的压缩文件交由服务器处理


    + ----------------- +                            + ------------ +                   + -------------- +
    |                   |                            |              |                   |                |
    |                   |  1. Acceptt-Encoding: ->   |              |  2.read file  ->  |                |
    |      Browser      |     gzip, deflate, br      |    Server    |                   |  Uncompressed  |
    |                   |                            |              |                   |  file          |
    |                   |  <- 4. content-Encoding:   |              |  <-  3. gzip      |                |
    |        ||         |        gzip                |              |                   |                |
    |       \||/        |                            |              |                   |                |
    |        \/         |        gzip content        |              |                   |                |
    |                   |                            |              |                   |                |
    + --- 5. ungzip --- +                            + ------------ +                   + -------------- +



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * 使用 webpack 进行预设压缩                    // 区别: webpack 提前将文件 按照指定格式 压缩
 * 
 * 
 * 对打包结果进行预压缩，可以减少服务器压缩的时间
 */


npm i -D compression-webpack-plugin


    + ----------------- +                            + ------------ +                   + -------------- +
    |                   |                            |              |                   |                |
    |                   |  1. Acceptt-Encoding: ->   |              |  2.read file  ->  |                |
    |      Browser      |     gzip, deflate, br      |    Server    |                   |  Uncompressed  |
    |                   |                            |              |                   |  file          |
    |                   |  <- 4. content-Encoding:   |              |  <-  3. gzip      |                |
    |        ||         |        gzip                |              |         content   |                |
    |       \||/        |                            |              |                   |                |
    |        \/         |                            |              |                   |                |
    |                   |                            |              |                   |                |
    + --- 5. ungzip --- +                            + ------------ +                   + -------------- +


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```


