## Problem

#### 类名冲突

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 类名冲突
 * 
 * 
 */

过深的层级不利于编写、阅读、压缩、复用

过浅的类名容易导致类名冲突


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 如何解决类名冲突


//- -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - -//


/**
 * 命名约定
 * 
 * 
 * 提供一种命名的标准，解决 类名冲突
 */

BEM, OOCSS, AMCSS, SMACSS ...


//- -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - -//


/**
 * CSS in JS                    // 此方案在手机端 React Native 中大放异彩
 * 
 * 
 */

利用 js 对象 表示样式，然后直接应用到元素的 style 中，这样以来 css 变成了 一个一个的对象
( 利用 JS 的语言优势，规避重用，重名等问题 )

1) 通过一个函数翻互殴一个样式对象

2) 把公共样式提取到公共模版中返回

3) 应用 JS 的各种特性操作对象，比如: 混合、提取、拆分...

4) ...


//- -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - -//


/**
 * CSS Module
 * 
 * 
 */

利用 webpack 模块化编写方案，简单易用、不重名等


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### 重复样式

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 重复样式
 * 
 * 
 * 重复样式不断出现在 css 代码中，增加了维护难度
 */

eg: 网站主色调: primary, info, wran, error, success ...

若网站已定义主色调( 并且已有部分颜色由主色调改变而来 )，一旦要做主色调调整，则会产生一个非常大的工程


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * CSS in JS                    // 此方案在手机端 React Native 中大放异彩
 * 
 * 
 * 由于放弃了选择选择器，很多写 css 的开发者并不是很适应
 */

利用 js 对象 表示样式，然后直接应用到元素的 style 中，这样以来 css 变成了 一个一个的对象
( 利用 JS 的语言优势，规避重用，重名等问题 )

1) 通过一个函数翻互殴一个样式对象

2) 把公共样式提取到公共模版中返回

3) 应用 JS 的各种特性操作对象，比如: 混合、提取、拆分...

4) ...


//- -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - -//


/**
 * 预编译器
 * 
 * 
 * 常见的 CSS预编译工具: less, sass             // 仅针对 CSS 的构建工具
 */

预编译器: CSS 进化版，支持变量，函数等高级语法，在书写时利用便捷的 预编译语法，生产时导出 符合 CSS 规范的代码


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### CSS 文件细分

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * CSS 文件细分
 * 
 * 
 */

大型项目中，CSS 也需要更细的拆分，有利于 CSS 代码的维护

在真是环境下，希望 CSS 文件越少越好，开发环境中，希望 CSS 文件分类越细越好


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * 依靠构建工具，例如 webpack 等
 * 
 * 
 */

利用 loader 或 plugin 打包、合并、压缩 CSS 文件


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

## Resolve

### 解决文件细分

#### css-loader

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * css-loader
 * 
 * 
 * 将 css 代码转换为 js 代码，以便 webpack 分析依赖和运行
 * 
 * 原理: 将 css 代码作为 字符串 导出
 */


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 简化版示例


.red {
    color: "#f40";
}


module.exports = `.red{
    color: "#f40";
}`


//- -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - -//


.red {
    color: "#f40";
    background: url('./bg.png');
}


const import = require('./bg.png');                 // 根据语法分析，利用 file-loader 返回 文件路径

module.exports = `.red{
    color: "#f40";
    background-url("${import1}");                   // 根据返回的 文件路径 填入
`;


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### style-loader

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * style-loader
 * 
 * 
 * 由于 css-loader 仅将 css 代码转换为字符串导出，并未将css 代码添加到页面 style 元素中
 * 
 * style-loader 可以将 css-loader 转换后的代码做进一步处理，将 css-loader 导出的字符串加入到页面的 style 元素中
 */


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 简化模拟原理

.red {
    color: "#f40";
}

module.exports = `.red{

    color: "#f40";
}`;


let style = module.exports,
    styleElem = document.createElement('style');

styleElem.innerHTML = style;

document.head.appendChild(styleElem);

module.exports = {};


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

### 解决类名冲突

#### BEM

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * BEM          // Block Element Modifier
 * 
 * 
 * 针对 CSS 类样式的一种命名方法
 */

block_elemnt_modifier               // 区域_组件_状态


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


block: 页面中的大区域，表示最顶级的划分

eg: 轮播图( banner ), 布局( layout ), 文章( article ) ...


element: 区域中的组成部分

eg: 轮播图中的横幅图片( banner_img ), 轮播图中的容器( banner_container ), 布局中的顶部( layout_header )

    文章中的标题( article_title ) ...


modifier: 可选，通常表示状态

eg: 处于展开状态的布局左边栏( layout_left_expand )，处于选中状态的轮播小圆点( banner_dot_selected ) ...


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 部分大型工程中，若使用 BEM 命名，可能会增加部分前缀，表示类名用途


l: layout           // 表示样式用于布局

c: component        // 表示样式为组件

u: util             // 表示样式为通用样式

j: javascript       // 表示样式无意义，仅为 js 使用


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### Css in JS

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * Css in JS
 * 
 * 
 * 使用 JS 对象来描述样式，而不是 CSS 样式表        // 这种描述形式 根本不存在类名，所以不会有类名冲突
 * 
 * vue, react 都支持 css in js, 可以非常轻松的应用到界面
 */


eg:

const style = {
    backgroundColor: '#f40',
    color: '#fff',
    width: '520px',
    height: '1314p',
    margin: '0 auto'
};


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// css in js 特点

1) 类名无冲突:

由于根本不存在类名，所以类名不会存在


2) 更加灵活:

可以充分利用 JS 语言灵活的特点，可以利用 函数，对象 及其他方式灵活处理


3) 应用面广:

只要支持 js 语言，就可以支持 css in js，因此，在一些用 JS 语言开发移动端应用的时候非常好用( 移动端可能并不支持 css )


4) 书写不便:

书写样式，特别是公共样式，处理起来不是很方便


5) 页面增加了大量冗余 css 代码:

在页面中处理 css in js 时，往往是将样式加入到元素的 style 属性中

会大量增加元素的内联样式，并且可能会有大量重复( 最终页面的代码不易阅读 )


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### Css Module

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * Css Module
 * 
 * 
 * css 模块化开发
 */


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 解决思路

1) css 类名冲突通常出现在大型项目中

2) 大型项目的构建通常使用模块化构建工具( eg: webpack ... )

3) 构建工具允许将 CSS 样式切分为更加精细的模块

4) 同 JS 变量一样，每个 CSS 模块中难以出现冲突的类名，冲突的类名往往发生在不同的 CSS 模块中

5) 只需要保证构建工具在合并 CSS 模块代码后不会出现 冲突的类名 即可


    + -------------- +                 + -------------- +
    |                |                 |                |
    |                |                 |                |
    |  CSS-Module1   |                 |                |
    |                |                 |                |
    |  CSS-Module2   | ==> webpack ==> |  Finnally-CSS  |
    |                |                 |                |
    |  CSS-Module3   |                 |                |
    |                |                 |                |
    |                |                 |                |
    + -------------- +                 + -------------- +
    
    可能有冲突的 CSS 模块                 合并后无 类名冲突CSS 


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 原理

开启 css-module 后，css-loader  会将样式中的类名进行转换为一个唯一的 hash 值

唯一的 hash 值: 由 '模块路径' + '类名' 生成


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


{ css-module1, css-module2, css-module3 ... } -> css-loader -> style-loader 

=> ['css-path', 'trandsformed-css-code' ...], locals{ class: 'hash' ... }


// step - 1: { css-module1, css-module2, css-module3 ... } -> css-loader

css-loader 会转换冲突的类名，并会将 原类名 和 hash类名 的关系作为对象 保留在其属性中


// step - 2: ['css-path', 'trandsformed-css-code' ...], locals{ class: 'hash' } -> style-loader

=> locals{ class: 'hash' ... }

style-loader 会直接返回 css-loader 中 locals 保存的 对应关系对象


//-------------------------------------------------------------------------------------------------------------------//


/**
 * 全局类名
 * 
 * 
 * 某些类名是全局的、静态的，不需要进行转换，仅需要在类名位置使用一个特殊的语法即可
 */

:global(.class) {       // 使用 global 的类名不会进行转换，相反没有使用 global 的类名，默认使用 locals
                        
}

:local(.class) {       // 默认使用 locals 的类名表示全局类名( 可以省略 local )，会被 css module 进行转换 

}


//-------------------------------------------------------------------------------------------------------------------//


/**
 * 如何控制最终的类名
 * 
 * 
 * 大部分情况，无需设置
 */

{
    test: /\.css$/,
    use: ["style-loader", {
        loader: "css-loader",
        options: {
            modules: {
                localIdentName: '[name]-[hash:5]'           // 设置最终产生类名的规则
            },
        }
    }],
}


//-------------------------------------------------------------------------------------------------------------------//


/**
 * 其他注意事项
 * 
 * 
 */

1) css-module 通常配合构建工具使用

2) css-module 仅处理顶级类名，规避书写嵌套类名( 已解决类名冲突，无需再嵌套 )

3) css-module 仅处理 类名( 不处理 标签选择器 )，不处理其他选择器

4) css-module 还会处理 id 选择器( id 选择器本就是唯一的 )

5) 使用 css-module 后，仅需要定义 语义化的类名即可，无需再尊需其他命名规范( eg: BEM )


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

### 解决重复样式

#### 预编译器

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 预编译器             // LESS & SASS
 * 
 * 
 * 简洁的书写 css 代码，再通过编译器，将其转换为可被浏览器识别的传统 css 代码
 */


1) 重复的样式值: 例如常用颜色，尺寸等

2) 重复的代码段: 例如绝对定位，居中，清除浮动等

3) 重复的嵌套书写

4) ...


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//



    简洁的书写 样式代码                                  普通 CSS 样式代码
                            ==> 预编译器转译 ==>
      无法被浏览器识别                                   可以被浏览器识别


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### Less

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * Less
 * 
 * 
 */

npm i -D less


//-------------------------------------------------------------------------------------------------------------------//


@red: #f40; // 变量: 可直接运算( 不同单位的运算虽然可以运算，但尽量规避 )
@width: 10px;
@height: 20px;

.red {
  color: @red;
}

.box {
  width: @width * 2;
  height: @height + 10px;
}


/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */


.border() { // 仅在开发时显示
  border: 1px solid red;
}

.color() { // 仅在开发时显示
  background-color: black;
}

.center(@type:relative) { // 可以当作函数传参使用( 可以设置默认值 )
  position: @type;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
}

.target { // 混合
  .border();
  .color();
  .center(absolute)
}


/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */


.wrap { // 选择器可直接嵌套

  background-color: #999;
  color: #fff;

  > .con {
    margin: 0 auto;
    height: 40px;

    .con-l {
      float: left;

      .btn {
        background-color: #999;

        &.selected { // 选择选中状态的按钮
          background-color: red;
        }
      }
    }

    .con-r {
      float: right;
    }

    &::after { // &: 表示接着某个元素继续选择
      clear: both;
      display: block;
      content: " ";
    }
  }
}


/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */


@some: red;

.demoFn {
  margin: if((2>1), 0, 3px); // less 条件判断
  color: if((iscolor(@some)), @some, black); // less 自带函数
}


/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */


@primary: #999999;
@commonColor: #fff;

.s1 {
  background-color: @primary;
  color: @commonColor;
}

.s2 {
  background-color: darken(@primary, 20%); // 在原有基础颜色上加深 20%
  color: @commonColor;
}

.s3 {
  background-color: darken(@primary, 40%); // 在原有基础颜色上加深 40%
  color: @commonColor;
}


/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */


@width: 100px; // 全局变量
@height: 100px; // 全局变量

.personal {

  @width: 50px; // 局部变量
  @height: 50px; // 局部变量
  @privateColor: red;

  .con {
    width: @width; // 重名变量，优先使用距离自身作用域最近的变量
    height: @height;
  }
}

.other {
  width: @width;
  height: @height;
  //color: @privateColor; // 无法使用其他其他选择器中的局部变量
}


/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */


/* css 注释: 不需要转译 */

// less 注释: 会转译为 css 注释 ( 建议使用，因开发时看的源代码为 less )


/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */


@import "common"; // 引入其他 less 模块

.test {
  color: @info; // 可引用其他模块的全局变量
  background-color: @danger;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### PostCss

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * PostCss                  // 类似于 webpack
 * 
 * 
 * CSS 工程化面临着诸多问题，PostCss 类似于一个编译器( 将样式源代码编译为最终浏览器可执行的 CSS 代码 )
 * 
 * 集成解决 CSS 工程化的工具
 */

npm i -D postcss; npm i -D postcss-cli;

postcss source.pcss -o output.css                // 将指定源文件转换为浏览器可识别的 css 文件


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


PostCss 库提供了对应的 JS API 用于转换代码，若需要使用 PostCss 的高级功能( 或开发 PostCss 插件 )

则需要 PostCss API: http://api.postcss.org/


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


PostCss 与 Less&Sass 思路不同: PostCss仅做了一些代码分析，将分析的结果交给插件，具体代码转换操作是由插件完成


    简洁的书写 样式代码              PostCss                     普通 CSS 样式代码
                        =================================>
      无法被浏览器识别      Plugin1, Plugin1, Plugin1 ...        可以被浏览器识别


//-------------------------------------------------------------------------------------------------------------------//


                  + ----------------------- PostCss -------------------------- +
                  |                                                            |
    Css-source -> | Parser -> [ plugin1, plugin2, plugin3 ... ] -> Stringofier | -> new Css
                  |                                                            |
                  + ---------------------------------------------------------- +


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### postcss.config.js

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * postcss.config.js
 * 
 * 
 * 使用 postcss, 需要设置 postcss.config.js
 */

module.exports = {
    map: false          // 关闭 source-map
};


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

## plugin of postcss

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * postcss-loader
 * 
 * 
 * postcss 工程化由 webpack 控制
 */

npm i -D postcss-loader


{
    test: /.pcss$/,
    use: ["style-loader", "css-loader?modules", "postcss-loader"]
},


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

### postcss-preset-env

[postcss-plugins](https://www.postcss.parts/)

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * postcss-preset-env               // 预设环境插件集合
 * 
 * 
 * 整合了常用的 postcss 插件
 */

npm install postcss-preset-env


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// index.pcss

::placeholder {
    color: red;
}

// index.css

::-moz-placeholder {
    color: red;
}

:-ms-input-placeholder {
    color: red;
}

::-ms-input-placeholder {
    color: red;
}

::placeholder {
    color: red;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### 自动厂商前缀

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 自动厂商前缀                       // 解决 css 部分代码兼容性
 * 
 * 
 * 自动调用依赖的 autoprefixer 库
 */


//-------------------------------------------------------------------------------------------------------------------//



/**
 * 调整兼容浏览器的范围
 * 
 * 
 */

可通过 https://brewserl.ist/ 对匹配结果进行查询         // browserlist 的数据来自于 CanIUse 网站，数据并非实时，并非很精准


last 2 version              // 匹配浏览器兼容最近期的两个版本

> 1% in CN                  // 匹配中国大于 1% 使用的浏览器，in CN ( 可省略，省略后代表 全球 )

not ie <= 8                 // 匹配除版本号小于等于 8 的 IE浏览器


//- -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - -//


// method - 1: 在 postcss-preset-emv 的配置中加入 brewsers                 // 不建议使用

module.export = {

    plugins: {
    
        "postcss-preset-env": {
        
            browsers : [
            
                "last 2 version",
                "> 1%"
            ]
        }
    }
};


//- -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - -//


// method - 2: 创建 .browserslistrc, 并配置                              // 建议使用( 因其他插件也会调用此文件的 css 范围 )

last 2 version

> 1%


//- -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - -//


// method - 3: 在 package.json 的配置中加入 browserslist                  // 建议使用( 因其他插件也会调用此文件的 css 范围 )


"browserslist": [

    "last 2 version",
    "> 1%"
]


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### 使用未来的 CSS 语法

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * CSS 中某些前沿语法正在指定过程中，没有形成真正的标准，若使用该部分语法，需要浏览器的兼容和转译
 * 
 * 
 * 以前依赖于 cssnext 库，postcss-preset-env 包含了该库
 */

post-preset-env 的 stage 配置，设定 postcss-preset-env 需要对哪个阶段的 css 语法进行兼容处理( 默认值: 2 )


"postcss-preset-env": {
    stage: 0,                   // 若要使用前沿的语法，必须开启此配置
}


// 共 5 个阶段

stage 0: Aspirattional          // 早期草案，及其不稳定

stage 1: Experimental           // 仍然不稳定，但提议已被 W3C 公认

stage 2: Allowable              // 虽然还是不稳定，但已经可以使用了                     // 建议可使用

stage 3: Embraced               // 比较稳定，可能将来会发生一些小的变化，即将称为最终标准

stage 4: Standardized           // 所有主流浏览器都应支持的 W3C 标准


//-------------------------------------------------------------------------------------------------------------------//


/**
 * css varable              // 变量
 * 
 * 
 * 官方推出: 为了向前兼容，不会影响之前版本的 css 代码
 * 
 * 若不希望在最终文件中看到此类语法可配置 postcss-preset-env 中的 preserve: false 
 */

:root {                     // boostrap4 中使用等

    --css-varable: value;
    
    --lightColor: #ddd;
    --darkColor: #333;
}

.demo {

    color: var(--lightColor);
    background-color: var(--darkColor);
}


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * 自定义选择器
 * 
 * 
 * 
 */

// postcss

@custom-selector :--heading h1, h2, h3, h4, h5, h6
@custom-selector :--enter:focus,:hover

a:--enter {
    color: #f40;
}

:--heading {
    font-weight: bold;
}

:--heading.active {
    font-weight: bold;
}


// ouput

a:focus,a:hover {
    color: #f40;
}

h1,h2,h3,h4,h5,h6 {
    font-weight: bold;
}

h1.active,h2.active,h3.active,h4.active,h5.active,h6.active {
    font-weight: bold;
}


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * 嵌套
 * 
 * 
 * 
 */


// postcss

.a {
    color: red;

    & .b {
        color: green;
    }

    & > .b {
        color: blue;
    }

    &:hover {
        color: black;
    }
}


// ouput

.a {
    color: red
}


.a .b {
    color: green;
}


.a > .b {
    color: blue;
}


.a:hover {
    color: black;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

### postcss-apply

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * postcss-apply
 * 
 * 
 * 利用 CSS 新语法定义 CSS 代码片段，在需要时直接植入 预先定义的代码片段名即可
 */

npm install postcss-apply --save-dev


module.exports = {
    map: false,
    plugins: {
        "postcss-apply":{

        }
    }
};


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// postcss

:root {
    --center: {
        position: absolute;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
    }
}

.item {
    @apply --center;
}


// ouput

.item {
  position: absolute;
  left: 50%;
  top: 50%;
  -webkit-transform: translate(-50%, -50%);
  transform: translate(-50%, -50%);
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

### postcss-color-function

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * postcss-color-function
 * 
 * 
 * 根据输入的颜色，返回依据颜色的不同变化值
 */

npm install postcss-color-function


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// postcss

:root {
    --mainColor: #000;
}


body {
    color: color(var(--mainColor));

    color: color(var(--mainColor) a(90%));              // alpha 通道变化

    color: color(var(--mainColor) red(90%));            // red 通道变化

    color: color(var(--mainColor) tint(50%));           // linght 变化

    color: color(var(--mainColor) shade(50%));          // dark 变化
}


// output

body {
    color: rgb(0, 0, 0);

    color: rgba(0, 0, 0, 0.9);

    color: rgb(230, 0, 0);

    color: rgb(128, 128, 128);

    color: rgb(0, 0, 0);
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

### postcss-import

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * postcss-import           // postcss 加入 webpack，此功能已由 webpack 负责
 * 
 * 
 * 将 css-module 的导入语句直接导出到其他 css-module 中
 * 
 * 而不是将其他 css-module 的代码导入合并
 */


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

### stylelint

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * stylelint                    // 开发时书写校验工具
 * 
 * stylelint-config-standard    // 标准的 css 规则
 * 
 * 
 * 通过配置规则，检查开发时书写的规范            // 便于开发阅读和统一性
 */


npm install --save-dev stylelint

npm install --save-dev stylelint stylelint-config-standard


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * stylelint 匹配规则设置
 * 
 * 
 * 创建 .stylelint (json) 文件，用于设置 stylelint 依赖的匹配规则
 */

{
  "extends": "stylelint-config-standard",
  "rules": {
    "indentation": null                 // 将不期望报错的语法提示关闭 ( 设置为 null 即可 )
                                        // 也可以根据官方文档设置该语法的匹配规则
  }
}


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * 可以在 webstorm 中安装 intelij-stylelint-plugin
 * 
 * 
 * webstrom 将会根据匹配规则 检索错误并提示，而不是仅限于 控制台中运行的提示
 */


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

### mini-css-extract-plugin 

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 无论是 less-loader 还是 postcss-loader 
 * 
 * 
 * precss( less, postcss ... ) -> css-loader -> style-loader -> index.html( head.apppendChild(style{ result }) ) 
 * 
 * 最终都会以 页面顶部 style 存放样式
 */

mini-css-extract-plugin             // 用于抽离转译后最终的 css 代码，并导出

    - plugin: 负责生成 css 文件
    
    - loader: 负责记录要生成的 css 文件内容，同时导出开启 css-module 后的样式对象


npm install --save-dev mini-css-extract-plugin


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


{
    test: /\.css$/,
    use: [MiniCssExtractPlugin.loader, "css-loader?modules"],
},
{
    test: /.pcss$/,
    use: [MiniCssExtractPlugin.loader, "css-loader?modules", "postcss-loader"]
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```













