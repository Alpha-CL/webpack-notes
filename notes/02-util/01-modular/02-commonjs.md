## CommonJS

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


在 node.js 中，由于有且只有一个入口文件( 启动文件 )，而开发一个应用肯定会涉及到多个文件配合

因此，node.js 对模块化的需求比浏览器要大的多

由于 node.js 刚发布时，前端没有统一的官方模块化规范，因此起初选择使用 社区提供的 CommonJS 作为模块化规范


//-------------------------------------------------------------------------------------------------------------------//


/**
 * 什么是模块
 * 
 * 
 */

模块就是一个 JS 文件，它实现了一部分功能，并隐藏自己的内部实现，同时提供部分接口供其他模块使用

模块化有两个核心要素 '暴露': 供其他模块使用的接口 和 '隐藏': 自身内部的实现原理

任何一个正常的模块化标准，都具备默认隐藏模块中所有的实现，而通过语法或api来调用暴露的接口


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * 暴露接口的过程称为: 模块的导出
 * 
 * 
 */


                + ----------- util.js ------------- +
                |                                   |
                |                                   |
                |           + ---------------- +    |
                |           |                  |    |
                |           |                  |    |
                            |                  |    |
         functio-sort       |                  |    |
                            |                  |    |
                |           |  Hide internal   |    |
                |           |                  |    |
                            |  implementation  |    |
         obj-helper         |                  |    |
                            |                  |    |
                |           |                  |    |
                |           |                  |    |
                            |                  |    |
         string-name        |                  |    |
                            |                  |    |
                |           |                  |    |
                |           + ---------------- +    |
                |                                   |
                |                                   |
                + --------------------------------- +


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * CommonJS 
 * 
 * 
 ** commonjs 默认开启模块缓存，若同一模块已被加载过，则会自动使用之前导出的结果
 */

1) 若 JS 文件中存在 exports 或 require，则该 JS 文件是一个模块

2) 模块内的所有代码均为隐藏代码，包括 全局变量，全局函数，即对全局变量造成污染的任何内容

3) 若一个模块需要暴露一些 API 提供给 外部使用，必须使用 exports 导出，exports 是一个空对象，可以为该对象添加任何需要导出的内容

4) 若一个模块需要倒入其他模块，必须使用 requiree 导入，require 是一个函数，参数为导入模块的路径


//-------------------------------------------------------------------------------------------------------------------//

 
/**
 * exports.key = value: any;
 * 
 * 
 */

exports.key = prop/methods;                 // 导出单个属性或方法

exports.key = {                             // 导出多个属性或方法

    prop,
    method
};

exports.key = {                             // 导出多个属性或方法

    prop,
    method
};


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * require(url: string): ;
 * 
 * 
 * @url: 必须以 './ or ../' 开头( 无前缀表示倒入 node_modules 中的库 )
 */

const result = require('./demo.js');


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * invoking ( prop / method ) of required
 * 
 * 
 */

const result = require('./demo.js');

result.propName;                    // 获取导出中指定属性的值

result.method();                    // 执行导出中指定的方法


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### CommonJS Implementation Principle

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * commonjs 执行原理
 * 
 * 
 */

1) 为了保证高效的执行，仅加载必要的模块，node.js 只有执行到 require 函数时，才会加载并执行模块


2) 为了隐藏模块中的代码，node.js 执行模块时，会将模块中的所有代码放置到一个函数中执行，以保证不污染全局变量

(function(module){ // Module Code }());


3) 为了抱着鞥顺利的导出模块内容，node.js 做了以下处理

    - 在模块开始执行之前，初始化一个值 module.exports = {}
    
    - module.exports 即为模块的导出值

    - 为了方便开发者便捷的导出，node.js 在初始化完 module.exports 后，又声明了一个变量 exports = module.exports;


4) 为了避免反复加载同一模块，node.js 默认开启模块缓存，模块会在第一次加载时缓存返回结果，后续再次调用会直接导出的缓存中的返回结果


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * 模拟导出运行原理
 * 
 */

(function(module){

    module.exports = {};                            // 基础导出
    
    let exports = module.exports;                   // 为了方便开发者 便捷导出
    
    
    exports.prop = val;
    
    exports.methods = function() {
    
    };
    
    ...
    
    
    module.exports = val;                           // 更加灵活，可直接赋值

    module.exports.prop = val;
    
    module.exports.methods = function() {
    
    };
    
    ...


    retrun module.exports;

}());


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


console.log(module.exports === exports);            // true( module.exports 指向 exports )

module.exports = {                                  // 修改 module.exports 为新的对象地址

    getNumber() {

        return count++;
    },

    abc: 123
};


/**
 * 因在上面已经修改 module.exports 中存储的地址
 * 内部后续声明的 exports 无法指向已执行代码时改变的地址
 *
 * 因最终返回 module.exports 地址已更改，所以无法返回 exports 所对应原 module.exports 地址中的属性和方法
 */

exports.bcd = 234;                          // undefined( 改变 module.exports 指向后，exports对象已无法和 module.exports 关联 )

console.log(module.exports === exports);    // false( 修改了 module.exports 的指向 )


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * 建议使用 module.exports                           // 较为灵活
 * 
 * 
 ** exports 默认返回对象，并且无法重新赋值
 */

module.exports = val;

module.exports = {};


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```