# Modular-Introduction

#### Development Of Node

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * stage - 1
 * 
 * 
 */


在 JavaScript 语言刚刚诞生的时候，仅用于实现页面中一些小效果，当时一个页面所用到 JS 可能只有几百行

在这种情况下，语言本身所存在的一些缺陷往往被大家有意的忽略，因程序的规模太小，仅需开发人员规避即可

在这个阶段，并不存在专业的前端工程师，因前端需要做的事情并不多，则这部分工作往往由后端工程师顺带完成

第一阶段发生的大事情:

1) 1996 年，NetScape JavaScript 语言提交给欧洲的一个标准制定阻止 ECMA( 欧洲计算机制造商协会 ) 

2) 1998 年，NetScape 在与微软浏览器 IE 的竞争中失利，宣布破产



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * stage - 2
 * 
 * 
 */


ajax 的出现，逐渐改变了 JavaScript 在浏览器环境中所扮演的角色

目前，JS 不仅可以实现小的效果，还可以和服务器之间进行交互，以更好的体验来改变数据

JS 代码的数量开始逐渐增长，从最初的 几百行，到后来的几万行，前端程序逐渐变得复杂

后端开发者压力逐渐增加，致使一些公司开始招募专业的前端开发者

但此时，前端开发者的待遇远不及后端开发者，因前端开发者承担的开发任务相对于后端开发者来说，仍比较简单


因以下问题还未解决，所以限制了前端的发展

1) 浏览器解释执行 JS 速度太慢

2) 用户的电脑配置不足

3) 更多的 JS 代码带来了 '全局污染'，依赖关系混乱等


第二阶段的发生的大事件

1) IE 浏览器制霸市场后，几乎不更新

2) ES4.0 流产，导致 JS 语言 10 年间几乎毫无变化

3) 2008 年 ES5 发布，仅解决部分 JS API 的不足


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * stage - 3
 * 
 * 
 */


2008 年，谷歌推出 V8 引擎，将 JS 的执行速度腿上了一个新的台阶，甚至可以和后端语言媲美

用户电脑配置开始飞跃的提升，仅剩 全局变量污染 和 依赖混乱 的问题

2008 年 Ryan Dahl 正在为一件事情焦头烂额，它需要在服务端手写一个高性能的 web 服务，
该服务对于性能要求之高，以至于目前市面上已有的 web 服务产品都不能满足其需求

经过分析，他确定，如果要实现高性能，那么必须要尽少的减少线程，而减少线程，并避免不了要实用异步的处理方案

开始，他打算用 C/C++ 语言来编写，这个过程很痛苦

就在此时，谷歌 V8 引擎发布，他突然发现 JS 不就是实现 web 服务较好的选择，JS 天生就是 单线程，并且基于异步，又有了 V8 引擎的支持，
他的执行速度足以支撑一个服务器，谷歌的 V8 引擎也会不断的免费优化

于是，他基于开源的 V8 引擎，对源码做了一些修改，很快就完成了该项目

2009 年，Ryan 退出了该 web 服务项目，命名为 node.js

从此，JS 进入后端开发环境，不再局限于 Web 开发环境，ES 语言是一门真正的语言，他的宿主环境，决定了他的功能



node.js 的诞生，便把 JS 中最后的问题放到了台前 全局变量污染 和 依赖混乱，直到 node.js 是服务端，若不解决这个问题，
分模块开发就无法实现，而模块化开发是后端程序必不可少的内容

经过社区激烈的讨论，最终形成了一个模块化方案 CommonJS, 该方案解决了 全局变量污染 和 依赖混乱，该方案一出，即被 node.js 支持

于是 node.js 成为了为 JS 语言实现模块化开发的平台


第三阶段发生的大事件:

1) 2008 年，谷歌推出 V8 引擎

2) IE 市场逐步被 firefox 和 chrome 蚕食

3) 2009 年，node.js 发布，并附带 commonjs 模块化开发标准


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * stage - 4
 * 
 * 
 */
 
CommonJS 的出现打开了前端开发者的思路

既然后端可以使用模块化开发 JS，前端为何不可呢？

于是，有人开始把 CommonJS 运用到浏览器环境中，但实现较为困难，最终重新定义了一个模块化标准

很快 AMD 规范出现，它解决了 全局变量污染 和 依赖混乱，ECMA 后续对其又进行了改进

2015 年，ES6 发布，它提出了官方的模块化解决方案: ES6 模块化

从此以后，模块化开发成为了 JS 本身特有的性质，成为了可以编写大型应用的正是语言

于此同时，很多开发者和技术厂商发现了JS的无穷潜力

* 既然JS可以编写大型应用，那么自然需要像其他语言那样的开发框架

    - Angular，React，Vue 等前端开发框架出现
    
    - Express，Koa 等互殴段开发框架出现
    
    - 各种后端数据库驱动出现


* 要开发大型应用，自然少不了各种实用的第三方库的支持

    - npm 包管理器出现，使用第三方库变得及其方便
 
    - webpack 等构建工具出现，专门用于打包和部署

* 既然 JS 可以放到服务器环境，为什么不能放在其他终端环境中呢

    - Electron 发布，可以使用 JS 语言开发桌面应用
    
    - RN 和 VueX 等技术发布，可以使用 JS 语言编写移动端应用程序
    
    - 各种小程序出现，可以使用 JS 编写依附于其他应用的小程序
    
    - 目前还有很多厂商致力于将 JS 应用到其他的额终端设备，最终形成大前端生态环境



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### NodeJS

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * node.js
 * 
 * 
 */


node.js 遵循 ECMASCript 标准，但由于脱离了浏览器环境，因此

1) 可以在 node.js 中使用 ECMASCript 标准的任何语法或API，如: 循环，判断，数组，对象等

2) 不能在 node.js 中使用浏览器的 web api, 例如: dom对象，window对象，document对象等

由于大部分开发者是从浏览器端开发转向 node.js 开发的，为了降低开发者的额学习成本，node.js 中提供了一些和浏览器 web api 同样的对象和函数

如: console, setTiemeout, setInterval 等


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```
